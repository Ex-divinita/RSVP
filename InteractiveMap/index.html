<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Floor Plan - Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        body {
            background-color: #f0f2f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .active-floor {
            background-color: #1d4ed8 !important;
            color: white !important;
            border-color: #1d4ed8 !important;
        }

        /* Basic style for buttons */
        .control-btn {
             @apply px-4 py-2 bg-white border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all;
        }

        /* Custom styles for disabled look in viewer */
        .fabric-canvas-container { cursor: default !important; }
        .canvas-container { cursor: default !important; }
        .upper-canvas { cursor: default !important; } /* Ensure cursor is default over shapes */

        /* Loading Indicator Style */
        #canvas-wrapper::before {
            content: 'Loading Floor Plan...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b7280;
            font-size: 1.2em;
            z-index: 5; /* Above canvas, below buttons */
            display: none; /* Hidden by default */
        }
        #canvas-wrapper.loading::before {
            display: block;
        }

    </style>
</head>

<body class="min-h-screen flex flex-col">

    <!-- Header Section -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center">
        <div>
            <h1 class="text-2xl font-bold text-gray-800">Palace of Congresses - Interactive Floor Plan</h1>
            <h2 id="app-mode-subtitle" class="text-md text-gray-600">Viewer Mode</h2> <!-- Always Viewer -->
        </div>
        <div class="w-1/3">
            <input type="text" id="searchInput" placeholder="Search Exhibitors..."
                   class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
    </header>

    <!-- Main Canvas Area -->
    <main class="flex-grow container mx-auto p-4 flex justify-center items-center">
        <div id="canvas-wrapper" class="relative w-full max-w-6xl bg-white shadow-lg rounded-lg border border-gray-200">
             <!-- Added loading indicator pseudo-element via CSS -->
            <div class="absolute top-4 right-4 z-10 flex gap-2">
                <!-- Floor Switcher Buttons -->
                <button data-floor="-1"
                        class="floor-switcher w-10 h-10 rounded-full bg-white border-2 border-gray-300 font-bold text-gray-700 flex items-center justify-center shadow-md hover:bg-gray-100 transition-all">-1</button>
                <button data-floor="0"
                        class="floor-switcher w-10 h-10 rounded-full bg-white border-2 border-gray-300 font-bold text-gray-700 flex items-center justify-center shadow-md hover:bg-gray-100 transition-all">0</button>
                <button data-floor="1"
                        class="floor-switcher w-10 h-10 rounded-full bg-white border-2 border-gray-300 font-bold text-gray-700 flex items-center justify-center shadow-md hover:bg-gray-100 transition-all">1</button>
                <button data-floor="2"
                        class="floor-switcher w-10 h-10 rounded-full bg-white border-2 border-gray-300 font-bold text-gray-700 flex items-center justify-center shadow-md hover:bg-gray-100 transition-all">2</button>
            </div>
            <canvas id="floorPlanCanvas"></canvas>
        </div>
    </main>

    <!-- Footer - Removed all buttons -->
    <footer class="bg-white p-3 flex justify-center items-center gap-4 border-t border-gray-200">
        <span class="text-sm text-gray-500">Interactive Map Viewer</span>
    </footer>

    <!-- Exhibitor Info Modal (Read-Only) -->
    <div id="detailsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4">Exhibitor Details</h3>
            <!-- Display information, not input fields -->
            <div class="space-y-3 mb-6">
                 <div class="flex items-center gap-3">
                     <img id="modal-logo" src="" alt="logo" class="w-16 h-16 object-contain rounded border border-gray-200 flex-shrink-0">
                     <div>
                         <p><span class="font-medium text-gray-700">Exhibitor:</span> <span id="modalExhibitorName" class="text-gray-900 font-semibold"></span></p>
                         <p><span class="font-medium text-gray-700">Sector:</span> <span id="modalSector" class="text-gray-800"></span></p>
                         <p><span class="font-medium text-gray-700">Booth ID:</span> <span id="modalBoothId" class="text-gray-800"></span></p>
                     </div>
                 </div>
                 <!-- You could add more display fields here later if needed -->
            </div>
            <!-- Only Close button in viewer mode -->
            <div id="modal-footer-viewer" class="flex justify-end">
                <button id="closeModalBtn"
                        class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400">Close</button>
            </div>
        </div>
    </div>

    <!-- Tooltip for Hover Info -->
    <div id="tooltip"
         class="hidden absolute z-50 bg-white border border-gray-300 rounded-md shadow-lg p-2 max-w-xs pointer-events-none">
        <div class="flex items-center gap-3">
            <img id="tooltip-logo" src="" alt="logo" class="w-10 h-10 object-contain rounded flex-shrink-0">
            <div>
                <span id="tooltip-name" class="font-bold text-gray-800 block"></span>
                <span id="tooltip-sector" class="text-sm text-gray-600 block"></span>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Configuration ---
            const sectorColors = { // Keep colors for visual differentiation
                'Unassigned': { color: 'rgba(156, 163, 175, 0.5)', stroke: '#6b7280' }, 'Energy': { color: 'rgba(250, 204, 21, 0.5)', stroke: '#d97706' },
                'Manufacturing': { color: 'rgba(59, 130, 246, 0.5)', stroke: '#1d4ed8' }, 'Construction': { color: 'rgba(249, 115, 22, 0.5)', stroke: '#c2410c' },
                'Technology': { color: 'rgba(16, 185, 129, 0.5)', stroke: '#047857' }, 'Automotive': { color: 'rgba(239, 68, 68, 0.5)', stroke: '#b91c1c' },
                'Finance': { color: 'rgba(139, 92, 246, 0.5)', stroke: '#6d28d9' },
            };
            const PLACEHOLDER_LOGO_40 = 'https://placehold.co/40x40/cccccc/969696?text=Logo'; // Smaller for tooltip
            const PLACEHOLDER_LOGO_64 = 'https://placehold.co/64x64/cccccc/969696?text=Logo'; // Larger for modal

            // --- DOM Element References ---
            const canvasWrapper = document.getElementById('canvas-wrapper');
            const canvasEl = document.getElementById('floorPlanCanvas');
            const floorSwitchers = document.querySelectorAll('.floor-switcher');
            const searchInput = document.getElementById('searchInput');
            const appModeSubtitle = document.getElementById('app-mode-subtitle');
            // Removed references to editor buttons and load input label
            const detailsModal = document.getElementById('detailsModal');
            const modalLogo = document.getElementById('modal-logo');
            const modalExhibitorName = document.getElementById('modalExhibitorName');
            const modalSector = document.getElementById('modalSector');
            const modalBoothId = document.getElementById('modalBoothId');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const tooltip = document.getElementById('tooltip');
            const tooltipLogo = document.getElementById('tooltip-logo');
            const tooltipName = document.getElementById('tooltip-name');
            const tooltipSector = document.getElementById('tooltip-sector');

            // --- Application State ---
            let appState = { // Initialize with empty state until JSON is loaded
                activeFloor: 0,
                floors: {}
            };
            const currentMode = 'viewer'; // Hardcoded to viewer mode
            let activeModalObject = null;
            const customProperties = ['exhibitorName', 'logoUrl', 'sector', 'id']; // Still needed to read properties from JSON
            let isBackgroundLoading = false; // Flag to prevent rapid switching issues

            // --- Canvas Initialization ---
            const canvas = new fabric.Canvas(canvasEl, {
                width: canvasWrapper.clientWidth,
                height: (canvasWrapper.clientWidth * 2) / 3, // Maintain aspect ratio
                backgroundColor: '#f9f9f9',
                renderOnAddRemove: false // Optimize rendering, manual render calls needed
            });

             // --- Image Preloading Function ---
             const preloadImage = (url) => {
                return new Promise((resolve, reject) => {
                    console.log(`Preloading image: ${url}`); // DEBUG
                    const img = new Image();
                    img.onload = () => {
                        console.log(`Image preloaded successfully: ${url}`); // DEBUG
                        resolve(img);
                    };
                    img.onerror = (err) => {
                        console.error(`Error preloading image: ${url}`, err); // DEBUG
                        reject(new Error(`Failed to load background image: ${url}`));
                    };
                    img.src = url;
                });
            };


            window.addEventListener('resize', async () => { // **MODIFIED**: Made async
                console.log("Resizing canvas..."); // DEBUG
                const newWidth = canvasWrapper.clientWidth;
                const newHeight = (newWidth * 2) / 3;
                canvas.setWidth(newWidth);
                canvas.setHeight(newHeight);

                const floorData = appState.floors[appState.activeFloor];
                if (floorData && floorData.backgroundURL) {
                    console.log(`Resize: Attempting to reload background: ${floorData.backgroundURL}`); // DEBUG
                    canvasWrapper.classList.add('loading');
                    try {
                        // **MODIFIED**: Use preloadImage on resize as well
                        const preloadedImgElement = await preloadImage(floorData.backgroundURL);
                        fabric.Image.fromURL(floorData.backgroundURL, (fabricImg, isError) => {
                            canvasWrapper.classList.remove('loading');
                            if (fabricImg && !isError) {
                                console.log("Resize: Background image reloaded successfully."); // DEBUG
                                canvas.setBackgroundImage(fabricImg, () => {
                                    loadFloorObjects(floorData, true); // Re-add objects
                                }, {
                                    scaleX: canvas.width / fabricImg.width,
                                    scaleY: canvas.height / fabricImg.height
                                });
                            } else {
                                console.error(`Resize: Error creating Fabric image ${floorData.backgroundURL}. IsError: ${isError}`); // DEBUG
                                canvas.renderAll();
                            }
                        }, { crossOrigin: 'anonymous' });
                    } catch (error) {
                        console.error(`Resize: Error preloading background image ${floorData.backgroundURL}`, error); // DEBUG
                        canvasWrapper.classList.remove('loading');
                        canvas.renderAll();
                    }
                } else {
                    console.log("Resize: No background URL found, rendering canvas."); // DEBUG
                    canvas.renderAll();
                }
            });

            // --- Core Functions ---
            const switchFloor = async (floorNumber) => { // **MODIFIED**: Made async
                console.log(`Switching to floor: ${floorNumber}`); // DEBUG
                if (isBackgroundLoading) {
                    console.warn("Background image is already loading, please wait.");
                    return; // Prevent switching if already loading
                }
                if (!appState.floors || !appState.floors[floorNumber]) {
                    console.error(`Floor data for floor ${floorNumber} not found.`);
                    displayErrorMessage(`Floor data for floor ${floorNumber} not found in the loaded JSON.`);
                    updateFloorSwitcherStyles(floorNumber);
                    return;
                }

                isBackgroundLoading = true; // Set loading flag
                appState.activeFloor = floorNumber;
                canvas.clear();
                canvas.setBackgroundColor('#dddddd', canvas.renderAll.bind(canvas));
                canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
                canvasWrapper.classList.add('loading');
                updateFloorSwitcherStyles(floorNumber); // Update button style immediately

                const newFloorData = appState.floors[floorNumber];

                if (newFloorData.backgroundURL) {
                    console.log(`Attempting to preload background: ${newFloorData.backgroundURL}`); // DEBUG
                    try {
                        // **MODIFIED**: Wait for image to preload
                        const preloadedImgElement = await preloadImage(newFloorData.backgroundURL);
                        console.log(`Preload successful for ${newFloorData.backgroundURL}. Now setting as Fabric background.`);

                        // Now use Fabric.Image.fromURL (should load from cache)
                        fabric.Image.fromURL(newFloorData.backgroundURL, (fabricImg, isError) => {
                            canvasWrapper.classList.remove('loading');
                            isBackgroundLoading = false; // Reset loading flag
                            if (fabricImg && !isError && fabricImg.width && fabricImg.height) {
                                console.log(`Fabric background image ${newFloorData.backgroundURL} set successfully.`); // DEBUG
                                canvas.setBackgroundImage(fabricImg, () => {
                                    loadFloorObjects(newFloorData);
                                }, {
                                    scaleX: canvas.width / fabricImg.width,
                                    scaleY: canvas.height / fabricImg.height
                                });
                            } else {
                                console.error(`Error creating Fabric image ${newFloorData.backgroundURL}. IsError: ${isError}`); // DEBUG
                                displayErrorMessage(`Background image ${newFloorData.backgroundURL} missing or invalid.`);
                                loadFloorObjects(newFloorData);
                            }
                        }, { crossOrigin: 'anonymous' });

                    } catch (error) {
                        console.error(`Error during switchFloor for ${newFloorData.backgroundURL}:`, error); // DEBUG
                        canvasWrapper.classList.remove('loading');
                        isBackgroundLoading = false; // Reset loading flag
                        displayErrorMessage(error.message || `Failed to load background for floor ${floorNumber}.`);
                        loadFloorObjects(newFloorData); // Still try to load objects
                    }
                } else {
                    console.warn(`No backgroundURL specified for floor ${floorNumber}.`); // DEBUG
                    canvasWrapper.classList.remove('loading');
                    isBackgroundLoading = false; // Reset loading flag
                    canvas.setBackgroundColor('#f9f9f9', canvas.renderAll.bind(canvas));
                    loadFloorObjects(newFloorData);
                }
            };

            // Added 'isResize' flag to potentially skip full JSON parsing on resize
            const loadFloorObjects = (floorData, isResize = false) => {
                const objectsToLoad = floorData.objects || [];
                console.log(`Loading ${objectsToLoad.length} objects for floor ${appState.activeFloor}. Is resize: ${isResize}`); // DEBUG

                canvas.remove(...canvas.getObjects()); // Clear existing objects *before* loading new ones

                if (objectsToLoad.length > 0) {
                     // Using loadFromJSON for proper object instantiation from JSON data
                    canvas.loadFromJSON({ objects: objectsToLoad }, () => {
                        console.log(`Objects successfully loaded via loadFromJSON for floor ${appState.activeFloor}. Updating interactivity.`); // DEBUG
                        updateCanvasInteractivity(); // Set objects to non-selectable *after* loading
                        canvas.renderAll(); // Render only once after setting interactivity
                    });
                } else {
                    console.log(`No objects to load for floor ${appState.activeFloor}. Rendering empty canvas.`); // DEBUG
                    updateCanvasInteractivity(); // Ensure canvas properties are set correctly
                    canvas.renderAll(); // Render the empty canvas
                }
            }


            const displayErrorMessage = (message) => {
                 console.error("Displaying Error on Canvas:", message); // DEBUG
                 canvas.clear();
                 canvas.setBackgroundColor('#f9f9f9', canvas.renderAll.bind(canvas));
                 canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
                 canvasWrapper.classList.remove('loading'); // Ensure loading is hidden

                 const text = new fabric.Text(message, {
                     left: canvas.width / 2,
                     top: canvas.height / 2,
                     originX: 'center',
                     originY: 'center',
                     fontSize: 18,
                     fill: 'red',
                     textAlign: 'center',
                     selectable: false,
                     evented: false
                 });
                 canvas.add(text);
                 canvas.renderAll();
            }

            const updateFloorSwitcherStyles = (floorNumber) => {
                 floorSwitchers.forEach(btn => {
                    btn.classList.toggle('active-floor', parseInt(btn.dataset.floor, 10) === floorNumber);
                });
             }

            // Set objects to be non-selectable in viewer mode
            const updateCanvasInteractivity = () => {
                console.log("Updating canvas interactivity for viewer mode."); // DEBUG
                canvas.discardActiveObject();
                canvas.selection = false;
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'default';

                canvas.forEachObject(obj => {
                    const sector = obj.get('sector') || 'Unassigned';
                    const colors = sectorColors[sector] || sectorColors['Unassigned'];
                    const isBooked = obj.exhibitorName && obj.exhibitorName !== 'Unnamed Booth';

                    obj.set({
                        selectable: false,
                        evented: true,
                        fill: colors.color,
                        stroke: colors.stroke,
                        strokeWidth: 2,
                        opacity: 1,
                        hoverCursor: isBooked ? 'pointer' : 'default'
                    });
                });
                console.log("Interactivity updated."); // DEBUG
                 // Render is handled by the caller (loadFloorObjects or switchFloor callback)
            };

            // Show modal with read-only details
            const showModal = (targetObject) => {
                if (!targetObject || !targetObject.exhibitorName || targetObject.exhibitorName === 'Unnamed Booth') return;
                activeModalObject = targetObject;
                modalLogo.src = targetObject.get('logoUrl') || PLACEHOLDER_LOGO_64;
                modalLogo.onerror = () => { modalLogo.src = PLACEHOLDER_LOGO_64; };
                modalExhibitorName.textContent = targetObject.get('exhibitorName');
                modalSector.textContent = targetObject.get('sector') || 'Unassigned';
                modalBoothId.textContent = targetObject.get('id') || 'N/A';
                detailsModal.classList.remove('hidden');
            };

            const hideModal = () => {
                activeModalObject = null;
                detailsModal.classList.add('hidden');
            };

            // Show tooltip on hover
            const showTooltip = (targetObject) => {
                if (!targetObject || !targetObject.exhibitorName || targetObject.exhibitorName === 'Unnamed Booth') {
                    hideTooltip();
                    return;
                }
                const exhibitorSector = targetObject.get('sector');
                const bounds = targetObject.getBoundingRect(true);
                const canvasRect = canvas.getElement().getBoundingClientRect();
                tooltipName.textContent = targetObject.exhibitorName;
                tooltipLogo.src = targetObject.logoUrl || PLACEHOLDER_LOGO_40;
                tooltipLogo.onerror = () => { tooltipLogo.src = PLACEHOLDER_LOGO_40; };
                tooltipSector.textContent = exhibitorSector || '';
                tooltipSector.classList.toggle('hidden', !exhibitorSector);
                tooltip.style.display = 'block';
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;
                const scrollX = window.scrollX || window.pageXOffset;
                const scrollY = window.scrollY || window.pageYOffset;
                let topPos = canvasRect.top + scrollY + bounds.top - tooltipHeight - 10;
                let leftPos = canvasRect.left + scrollX + bounds.left + (bounds.width / 2) - (tooltipWidth / 2);
                if (canvasRect.top + bounds.top - tooltipHeight - 10 < 5) {
                    topPos = canvasRect.top + scrollY + bounds.top + bounds.height + 10;
                }
                if (canvasRect.left + bounds.left + (bounds.width / 2) - (tooltipWidth / 2) < 5) {
                    leftPos = scrollX + 5;
                }
                const viewportWidth = document.documentElement.clientWidth;
                if (canvasRect.left + bounds.left + (bounds.width / 2) + (tooltipWidth / 2) > viewportWidth - 5) {
                    leftPos = scrollX + viewportWidth - tooltipWidth - 5;
                }
                tooltip.style.left = `${leftPos}px`;
                tooltip.style.top = `${topPos}px`;
                tooltip.classList.remove('hidden');
                tooltip.style.opacity = 1;
            };

            const hideTooltip = () => {
                 tooltip.classList.add('hidden');
                 tooltip.style.opacity = 0;
                 tooltip.style.display = '';
            };

             // --- Search Functionality ---
            const searchExhibitor = () => {
                const query = searchInput.value.toLowerCase().trim();
                let found = false;
                 console.log(`Searching for: "${query}"`); // DEBUG
                canvas.forEachObject(obj => {
                     const sector = obj.get('sector') || 'Unassigned';
                     const colors = sectorColors[sector] || sectorColors['Unassigned'];
                     obj.set({
                         opacity: query ? 0.3 : 1, // Dim if searching, restore otherwise
                         stroke: colors.stroke,
                         strokeWidth: 2
                     });
                     const name = obj.get('exhibitorName');
                    if (query && name && name.toLowerCase().includes(query)) {
                        console.log(`Match found: ${name}`); // DEBUG
                        obj.set({ stroke: '#e11d48', strokeWidth: 4, opacity: 1 }); // Highlight
                        found = true;
                    }
                 });
                if (query && !found) {
                     console.log('No exhibitor found matching that name.');
                }
                canvas.renderAll();
            };

            // --- Event Listeners ---
            floorSwitchers.forEach(btn => {
                btn.addEventListener('click', () => {
                    const floorIndex = parseInt(btn.dataset.floor, 10);
                    if (!isBackgroundLoading && appState.floors && appState.floors[floorIndex]) { // Prevent clicks while loading
                         switchFloor(floorIndex);
                    } else {
                        console.warn(`Attempted to switch floor during load or to non-existent floor ${floorIndex}.`);
                    }
                });
            });

            // Double click to open modal
            canvas.on('mouse:dblclick', (options) => {
                if (options.target && options.target.exhibitorName && options.target.exhibitorName !== 'Unnamed Booth') {
                    showModal(options.target);
                }
            });

            // Hover effects
            canvas.on('mouse:over', (e) => {
                if (e.target) {
                    showTooltip(e.target);
                    if (e.target.exhibitorName && e.target.exhibitorName !== 'Unnamed Booth' && e.target.get('stroke') !== '#e11d48') {
                        e.target.set({ stroke: '#0ea5e9', strokeWidth: 4 });
                        canvas.renderAll();
                    }
                }
            });
             canvas.on('mouse:out', (e) => {
                if (e.target) {
                    hideTooltip();
                    const currentStroke = e.target.get('stroke');
                    // Only reset if it's the blue hover stroke AND not the red search stroke
                    if (currentStroke === '#0ea5e9') {
                        const sector = e.target.get('sector') || 'Unassigned';
                        const originalStroke = (sectorColors[sector] || sectorColors['Unassigned']).stroke;
                        e.target.set({ stroke: originalStroke, strokeWidth: 2 });
                        canvas.renderAll();
                    }
                }
            });

            // Modal close button
            closeModalBtn.addEventListener('click', hideModal);

            // Search input listener
            searchInput.addEventListener('input', searchExhibitor);
             searchInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') searchExhibitor(); });

            // --- JSON Load Functionality (AUTOMATIC) ---
             const loadInitialData = async () => {
                console.log("Attempting to load initial data from interactivemap.json..."); // DEBUG
                canvasWrapper.classList.add('loading');
                 try {
                     const response = await fetch('interactivemap.json');
                     if (!response.ok) {
                         throw new Error(`Could not load interactivemap.json: ${response.status} ${response.statusText}. Ensure the file is in the same folder.`);
                     }
                     const loadedData = await response.json();
                     console.log("JSON data fetched successfully:", loadedData); // DEBUG
                     if (loadedData.activeFloor !== undefined && loadedData.floors && typeof loadedData.floors === 'object' && Object.keys(loadedData.floors).length > 0) {
                         appState = loadedData;
                         let initialFloorKey = appState.floors.hasOwnProperty(appState.activeFloor) ? String(appState.activeFloor) : Object.keys(appState.floors)[0];
                         console.log(`Initial floor determined: ${initialFloorKey}`); // DEBUG
                         if (initialFloorKey !== undefined && appState.floors[initialFloorKey]) {
                             // **MODIFIED**: Initial switchFloor needs await here too
                             await switchFloor(parseInt(initialFloorKey, 10));
                         } else {
                             throw new Error("JSON file contains no valid floor data.");
                         }
                         console.log('Floor plan data processed and loaded successfully!');
                     } else {
                         throw new Error('Invalid JSON structure. Missing activeFloor, floors data, or floors object is empty.');
                     }
                 } catch (error) {
                     console.error("JSON Loading Error:", error);
                     displayErrorMessage(`Error loading map data:\n${error.message}\nPlease check 'interactivemap.json'.`);
                     canvasWrapper.classList.remove('loading');
                 }
             };

            // --- Initial Application Load ---
            appModeSubtitle.textContent = 'Viewer Mode';
            loadInitialData(); // Call the automatic load function

        });
    </script>
</body>
</html>

